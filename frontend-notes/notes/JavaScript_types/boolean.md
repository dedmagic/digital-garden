# Тип `Boolean`

## Falsy и truthy значения

Кроме булевского значения `false` есть ещё пять значений других типов, которые при приведении к логическому преобразовываются в значение `false`. Это числовые значения 0 (и -0) и `NaN`, пустые строки, `null` и `undefined`. Их называют falsy-значениями:

```js
console.log(Boolean(false)); // => false
console.log(Boolean(null)); // => false
console.log(Boolean(undefined)); // => false
console.log(Boolean(0)); // => false
console.log(Boolean(-0)); // => false
console.log(Boolean(NaN)); // => false
console.log(Boolean('')); // => false
```

Все остальные значения преобразовываются в `true` и, соответственно, называются truthy-значениями.

Внимание! В том числе к truthy-значениям относятся пустые массивы и объекты:

```js
console.log(Boolean([])); // => true
console.log(Boolean({})); // => true
console.log(Boolean('false')); // => true
console.log(Boolean([false])); // => true
```

Эту особенность можно использовать для сокращённой записи логических выражений. Например, если перед использование объекта необходимо проверить его существование, то это можно сделать таким образом:

```js
if (obj !== null && obj !== undefined) {
    console.log('Объект существует');
} else {
    console.log('Объект не существует');
}
```

Или, благодаря тому, что `null` и `undefined` являются falsy-значениями, так:

```js
if (obj) {
    console.log('Объект существует');
} else {
    console.log('Объект не существует');
}
```

Внимание! Эти два фрагмента кода не равнозначны. В первом условие будет ложным только для значений `null` и `undefined`, во втором – для всех falsy-значений.

Минутка юмора: как всегда в JavaScript, неявными преобразованиями типов лучше не пользоваться, это может приводить к очень интересным результатам:

```js
console.log([] == ![]); // => true
```

## Сокращённое вычисление логических выражений

Вычисление логических выражений в JavaScript происходит по схеме "short circuit evaluation", т.е. они вычисляются слева направо и, как только становится очевидным значение всего выражения, оставшиеся части не вычисляются. Это важно в том случае, если логическое выражение имеет побочные эффекты.

Пример:

```js
let y = 42;
if (x > 4 && y++ > 0) {
    ...
}
console.log({ y });
```

Окончательное значение переменной `y` зависит от того, истинно ли подвыражение `x > 4`. Если да, то будет вычисляться подвыражение `y++ > 0` и `y == 43`, если же нет, то второе подвыражение не вычисляется и `y == 42`.

## Хаки JavaScript, связанные с логическими вычислениями

### Преобразование в логический тип в с помощью двух операций логического отрицания

```js
let str = 'Hello world';
let empty_string = '';
let arr = [];
let obj = {};

console.log(!!str); // => true
console.log(!!arr); // => true
console.log(!!obj); // => true
console.log(!!42); // => true
console.log(!!Infinity); // => true

console.log(!!empty_string); // => false
console.log(!!0); // => false
console.log(!!NaN); // => false
console.log(!!null); // => false
console.log(!!undefined); // => false
```

### Проверка существования объекта перед его использованием

Основана на сокращённом вычислении логических выражений и является заменой оператора `if`.

```js
let obj1 = { a: 42 };
let obj2 = null; // or undefined

console.log(obj1 && obj1.a); // => 42
console.log(obj2 && obj2.a); // => null
```

При отсутствии проверки в последней строке примера код будет падать.

Однако в современном JavaScript для этих целей специальная операция "элвис":

```js
console.log(obj1?.a); // => 42
console.log(obj2?.a); // => null
```


### Явная замена оператора `if`

Для примера возьмём код, выводящий нечётные натуральные числа, меньшие десяти:

```js
for (let i = 0; i < 10; i++) {
    if (i % 2 == 1) {
        console.log(i);
    }
}
```

Благодаря сокращённому вычислению логических выражений, оператор `if` можно заменить на операцию `&&`:

```js
for (let i = 0; i < 10; i++) {
    (i % 2 == 1) && console.log(i);
}
```

Данный подход ухудшает читабельность кода, и его стоит избегать. Однако, из этого правила есть исключения: иногда нужно условное выполнение в коде, в которм есть вычисление выражений, но нельзя использовать операторы (шаблоны React?).

Маленькое лирическое отступление: благодаря тому, что 0 – это falsy-значение, код можно ещё подсократить:

```js
for (let i = 0; i < 10; i++) {
    (i % 2) && console.log(i);
}
```

### Использование значений объектов по умолчанию

В случаях, когда код на входе ожидает некоторый объект, и, если этот объект отсутствует, то используется некоторое дефолтное значение, тоже можно обойтись без оператора `if`:

```js
let options = null;

options = options || { width: 42 };
console.log(options); // => { width: 42 }
```

```js
let options = { font: 'Verdana' };

options = options || { width: 42 };
console.log(options); // => { font: 'Verdana' }
```

Примечание: в этом примере рассматривается только ситуация с полным отсутствием объекта на входе. Если же нужно значение по умолчанию применять на уровне отдельных настроек (отдельных свойств объекта с настройками), то тогда нужно использовать технику слияния объектов. В заметке [Оператор расширения (spread)](../JavaScript/spread.md#объекты "spread") см. раздел "Объекты. Слияние объектов".
