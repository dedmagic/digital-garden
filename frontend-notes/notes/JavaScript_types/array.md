# Массивы в JavaScript

## Индексы массивов

Несмотря на то, что с индексами массивов всегда работают как с целыми числами, на самом деле они являются обычными (ну почти обычными 🙂) свойствами объекта, т.е. строками:

```js
const arr = [1, 2, 3, 4];

arr['2'] = 42;
console.log(arr); // --> [ 1, 2, 42, 4 ]
```

## Разреженные массивы

Массив не обязательно заполнен непрерывно, от минимального индекса до максимального, некоторые элементы могут отсутствовать.

Внимание! Эти элементы не равны `undefined`, они действительно _отсутствуют_.

Массив, в котором некоторые элементы отсутствуют, называется _разреженным_ (sparse array).

Разреженный массив может появится в следующих случаях:

* какие-то из элементов удалены (`delete`)

```js
const arr1 = [1, 2, 3, 4];
delete arr1[2];
console.log(arr1); // --> [ 1, 2, <1 empty item>, 4 ]

delete arr1[1];
console.log(arr1); // --> [ 1, <2 empty items>, 4 ]
```

* массив создан с указанием количества элементов, но ещё не заполнен:

```js
const arr2 = new Array(6);
console.log(arr2); // --> [ <6 empty items> ]
```

* при увеличении размера массива через изменение свойства `length`:

```js
const arr3 = [1, 2, 3, 4];
arr3.length = 6;
console.log(arr3); // --> [ 1, 2, 3, 4, <2 empty items> ]
```

## Способы создания массивов

- Литерал массива

```js
const arr1 = [];
console.log(arr1); // --> []

const arr2 = [1, 2, 3, 4];
console.log(arr2); // --> [ 1, 2, 3, 4 ]
```

- `new Array()`

Конструкция `new Array()` в JavaScript ведёт себя неконсистентно: при передаче нескольких параметров все они становятся _значениями элементов_ создаваемого массива, если же параметр один, он расценивается как _размер_ создаваемого массива. 

```js
const arr3 = new Array(1, 2, 3, 4);
console.log(arr3); // --> [ 1, 2, 3, 4 ]

const arr4 = new Array(6);
console.log(arr4); // --> [ <6 empty items> ]
```

- `Array.of`

Исправить ситуацию призван метод `Array.of` – он ведёт себя также, как и `new Array()`, с той только разницей, что передача единственного параметра приводит к созданию массива из одного элемента:

```js
const arr5 = Array.of(1, 2, 3, 4);
console.log(arr5); // --> [ 1, 2, 3, 4 ]

const arr6 = Array.of(6);
console.log(arr6); // --> [ 6 ]
```

- `Array.from`

Метод `Array.from` позволяет создавать массивы из итерируемых и массивоподобных объектов:

```js
const str = 'Hello world!';
const arr7 = Array.from(str);
console.log(arr7); // --> [ 'H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!' ]

const set = new Set();
set.add(42);
set.add(96);
set.add(13);

const arr8 = Array.from(set);
console.log(arr8); // --> [ 42, 96, 13 ]
```

В качестве второго параметра можно передать функцию преобразования значения, которая будет применяться к каждому создаваемому элементу массива:

```js
const arr9 = Array.from(set, item => item * 2);
console.log(arr9); // --> [ 84, 192, 26 ]
```

Т.е. подобная конструкция равнозначна последовательному вызову `Array.from` и `map`: `Array.from(...).map(...)`, но не приводит к созданию промежуточного массива.

```js
const arr9_1 = Array.from(set).map(item => item * 2);
console.log(arr9_1); // --> [ 84, 192, 26 ]
```

Примечание 1: у `Array.from` есть третий параметр – контекст выполнения (`this`) для функции преобразования.

Примечание 2: если источник является разреженным массивом или разреженным массивоподобным объектом, то для пустых слотов создаются элементы массива со значением `undefined`, т.е. результат не является разреженным.

```js
const arr10 = new Array(4);
console.log(arr10); // --> [ <4 empty items> ]
const arr11 = Array.from(arr10);
console.log(arr11); // --> [ undefined, undefined, undefined, undefined ]
```

* spread + литерал массива

Комбинация операции spread и литерала массива позволяет создавать массивы из итерируемых объектов:

```js
const arr10 = [...set];
console.log(arr10); // --> [ 42, 96, 13 ]

const arr11 = [...str];
console.log(arr11); // --> [ 'H', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '!' ]

const arr14 = new Array(4);
const arr15 = [...arr14];
console.log(arr15); // --> [ undefined, undefined, undefined, undefined ]
```

Как видно из последнего примера, разреженные массивы при этом преобразуются в неразряженные.

## Массивоподобные объекты

Массивоподобный объект – это объект, содержащий числовое свойство `length` и свойства с "числовыми" именами (т.е. свойства с именами "0", "1", "2" и т.д.).

```js
const obj = {
    '0': 42,
    '1': 96,
    '7': 123,
    length: 5
}
```

Объект из примера подобен разреженному массиву `[ 42, 96, undefined, undefined, undefined ]`.

Некоторые методы для работы с DOM, такие как `document.querySelectorAll`, а также функции библиотеки jQuery возвращают массивоподобные объекты.

Массивоподобные объекты могут быть преобразованы в массивы с помощью `Array.from` и не могут быть преобразованы с помощью spread, т.к. не являются итерируемыми (отсюда ещё один вывод – по ним нельзя пройтись с помощью цикла `for/of`).

```js
const arr = Array.from(obj);
console.log(arr); // --> [ 42, 96, undefined, undefined, undefined ]

const arr2 = [...obj]; // --> TypeError: obj is not iterable
```

Для массивоподобного объекта невозможно вызвать методы массива, т.к. все эти методы хранятся в `Array.prototype`, а у массивоподобного объекта прототип другой:

```js
const bigs = numbers.filter(item => item > 50); // --> TypeError: numbers.filter is not a function
```

Чтобы вызвать метод массива для массивоподобного объекта, можно воспользоваться двумя способами:

1. Изменить контекст вызова функции с помощью `call` или `apply`:

```js
const bigs1 = Array.prototype.filter.call(numbers, item => item > 50);
console.log(bigs1); // --> [ 96, 123 ]
```

2. Преобразовать такой объект в массив (`Array.from`):

```js
const bigs2 = Array.from(numbers).filter(item => item > 50);
console.log(bigs2); // --> [ 96, 123 ]
```

3. Изменить тип объекта на тип `Array`

```js
numbers.__proto__ = Array.prototype
const bigs3 = numbers.filter(item => item > 50);
console.log(bigs3) // --> [ 96, 123 ]
```
