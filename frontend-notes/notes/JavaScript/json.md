# Работа с JSON

## Методы `JSON.stringify()` и `JSON.parse()`

Для сериализации в формат JSON используется метод `JSON.stringify()`, который на входе ожидает объект, на выходе даёт JSON-строку:

```js
const obj = {
    x: 1,
    y: {
        z: [false, null, '']
    }
}

const json1 = JSON.stringify(obj);
console.log(json1); // --> {"x":1,"y":{"z":[false,null,""]}}
```

Можно передавать значения любого типа (не обязательно объекты), но в таком случае просто произойдёт преобразование в обычную строку.

Для десериализации используется метод `JSON.parse()`:

```js
const obj2 = JSON.parse(json1); // --> { x: 1, y: { z: [ false, null, '' ] } }
```

## Допустимые в JSON типы данных

Сериализовывать в JSON можно:
- числа
- строки
- true, false
- null
- массивы, содержащие перечисленные выше элементарные значения
- объекты, содержащие перечисленные выше элементарные значения

Даты тоже сериализуются, но при этом преобразуются в строку ISO 8601.

Важно! Используются только двойные кавычки, как для имён свойств, так и для строковых значений. Апострофы не используются.

Сериализуются только перечислимые собственные свойства объекта.

```js
const obj3 = {
    nullProp: null,
    undefinedProp: undefined,
    nanProp: NaN,
    infinityProp: Infinity,
    minusInfinityProp: -Infinity,
    dateProp: new Date(),
    functionProp: function () { return 42; }
}

const json3 = JSON.stringify(obj3); // --> {"nullProp":null,"nanProp":null,"infinityProp":null,"minusInfinityProp":null,"dateProp":"2022-01-23T06:51:28.085Z"}

const obj4 = JSON.parse(json3);
/* -->
{
  nullProp: null,
  nanProp: null,
  infinityProp: null,
  minusInfinityProp: null,
  dateProp: '2022-01-23T06:51:28.085Z'
}
*/
```

## Форматирование JSON-строки

По умолчанию, результат сериализации выглядит следующим образом:

```js
const obj1 = {
    x: 1,
    y: {
        z: [false, null, ""]
    }
}

const json1 = JSON.stringify(obj1); // -->  {"x":1,"y":{"z":[false,null,""]}}
```

Т.е. в одну строку, без пробелов. Чтобы сделать JSON-строку более человекочитаемой, необходимо в метод `JSON.stringify()` в качестве второго параметра передать `null`, а в качестве третьего – строку из одного или нескольких пробельных символов (white space):

```js
const json3 = JSON.stringify(obj1, null, '  '); // Два пробела
/* -->
{
  "x": 1,
  "y": {
    "z": [
      false,
      null,
      ""
    ]
  }
}
*/

const json2 = JSON.stringify(obj1, null, '\t');
/* -->
{
	"x": 1,
	"y": {
		"z": [
			false,
			null,
			""
		]
	}
}
*/
```

Метод `JSON.parse()` игнорирует пробельные символы, поэтому их наличие на десериализацию никак не влиет.

## Метод `toJSON()`

Если в объекте определён метод `toJSON()`, то при сериализации вместо стандартных алгоритмов будет вызван именно он:

```js
const obj1 = {
    x: 1,
    y: new Date(),
    toJSON: function () {
        return `${this.y.toLocaleDateString()} ${this.x}`;
    }
}

const json1 = JSON.stringify(obj1); // --> "23.01.2022 1"
```

Примечание: это демонстрационный пример, в нём не происходит нормальная сериализация и при попытке десериализовать будет получена ошибка.

## Кастомная сериализация: список сериализуемый полей

Если необходимо сериализовать не все свойства объекта, в качестве второго параметра в метод `JSON.stringify()` нужно передать массив строк, содержащих имена свойств, подлежащих сериализации. При этом в результат свойства объекта попадут в том же порядке, в котором они перечислены в этом массиве:

```js
const obj1 = {
    x: 1,
    y: 2,
    z: 3
}

const json2 = JSON.stringify(obj1, ['z', 'y']); // --> {"z":3,"y":2}
```

## Кастомная сериализация: алгоритм для каждого свойства

Сериализацией можно тонко управлять, для этого в метод `JSON.stringify()` в качестве второго параметра нужно передать функцию, которая в свою очередь принимает два параметра: сериализуемое свойство и значение этого свойства. При этом при первом вызове будет передана пустая строка в качестве имени свойства и сам объект в качестве значения:

```js
function replacer(key, value) {
    console.log(`${key} --> ${value}`); // Логирование

    if (key === '') {
        return value;
    }

    if (key === 'y') {
        return undefined;
    }
    return `>>> ${value} <<<`;
};

const json3 = JSON.stringify(obj1, replacer); // --> {"x":">>> 1 <<<","z":">>> 3 <<<"}

/* Логирование
 --> [object Object]
x --> 1
y --> 2
z --> 3
*/
```

Важно! Если при первом вызове (для всего объекта) функция преобразования вернёт что-либо отличное от самого, итерации по свойствам не будет:

```js
function replacer(key, value) {
    console.log(`${key} --> ${value}`); // Логирование

    if (key === 'y') {
        return undefined;
    }
    return `>>> ${value} <<<`;
};

const json3 = JSON.stringify(obj1, replacer); // --> ">>> [object Object] <<<"

/* Логирование
 --> [object Object]
*/
```

## Кастомная десериализация

Аналогично, при десериализации в метод `JSON.parse()` вторым параметром можно передать функцию, которая будет вызвана для каждого свойства объекта и _в конце_ для всего объекта:

```js
const obj1 = {
    x: 1,
    y: 2,
    z: 3
}

const json1 = JSON.stringify(obj1);

function reviver(key, value) {
    console.log(`${key} --> ${value}`); // Логирование
    return value;
}

const obj2 = JSON.parse(json1, reviver); // --> { x: 1, y: 2, z: 3 }
/* Логирование:
x --> 1
y --> 2
z --> 3
 --> [object Object]
*/
```
