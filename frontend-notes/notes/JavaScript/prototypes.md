# Прототипы

Создадим объект:

```js
const obj = {
    a: 42,
    b: 96
}
```

Хотя объект создан только с двумя свойствами `a` и `b`, для него мы можем вызвать методы, например, `hasOwnProperty` или `toString`:

```js
console.log(obj.hasOwnProperty());
console.log(obj.toString());
```

Вопрос: откуда они взялись?


Если посмотреть на объект в консоли браузера, то можно увидеть, что кроме свойств, указанных у объекта при его создании, есть ещё целый набор свойств и методов, объединённых в раздел `[[Prototype]]`:

![Объект в консоли](img/obj_console.png)


Создание объекта с помощью литерала аналогично вызову функции-конструктора `new Object(...)`, поэтому посмотрим внимательнее на эту функцию-конструктор.

## Свойство `Object.prototype`

У всех функций-конструкторов встроенных типов JavaScript есть свойство `prototype`, которое содержит ссылку на предопределённый объект (рассмотрим на примере типа `Object`):

![Object.prototype](img/Object.prototype.png)

Этот объект является хранилищем свойств и методов данного типа.  
Т.к. у этого объекта нет своего имени, его так и называют: `Object.prototype`.

## Свойство `[[Prototype]]` (`__proto__`)

При создании объекта с помощью функции-конструктора `const obj = new Object(...)` этому объекту автоматически добавляется внутреннее свойство `[[Prototype]]`, в которое копируется значение свойства `prototype` типа `Object`, т.е. ссылка на объект `Object.prototype`:

![`obj.[[Prototype]]`](img/obj_proto.png)

**Примечание 1:** создание объекта с помощью литерала равносильно вызову конструктора: `const obj = {...}` <=> `const obj = new Object(...)`.

**Примечание 2:** под таким именем это свойство фигурирует в спецификации ECMAScript и так же его отображает Google Chrome, Firefox же отображает его как `<prototype>`.

Свойство недоступно для чтения/записи, но для него существует свойство доступа (комбинация геттера и сеттера) `__proto__` (два подчёркивания в начале и в конце).

**Примечание 1:** это свойство реализовано для всех платформ выполнения, т.е. для браузеров и Node.js.

**Примечание 2:** на данный момент это свойство не рекомендуется для использования (является depricated), вместо него нужно использовать пару методов `getPrototypeOf`/`setPrototypeOf`.

**Примечание 3:** хотя язык предоставляет возможность изменения прототипа существующего объекта, эта операция может иметь очень негативные последствия с т.з. производительности, поэтому делать так без крайней необходимости не стоит. Лучше создать копию объекта с нужным прототипом.

Таким образом

```js
console.log(obj.__proto__ === Object.prototype); // --> true
```

## Цепочка наследования

При обращении к свойству или методу объекта исполняющая среда сначала производит поиск этого члена объекта в нём самом. Если обнаружить не удалось, тогда происходит переход к объекту, ссылка на который хранится в `[[Prototype]]`, и поиск происходит в этом объекте. Если же и в нём нет такого члена, тогда происходит переход к его прототипу, и так до тех пор, пока не будет обнаружен искомый метод (или свойство) или пока цепочка прототипов не оборвётся – в `[[Prototype]]` вместо ссылки будет `null`.

Таким образом, при обращении к методу `obj.hasOwnProperty()` произошёл вызов `Object.prototype.hasOwnProperty()`. 

## Свойство `prototype` встроенных типов

Все встроенные ссылочные (объектные) типы JavaScript (`Array`, `String`, `Date`, ...) имеют функцию-конструктор, свойство `prototype` которого ссылается на соответствующий объект-хранилище свойств и методов, поэтому, например, у всех строк есть метод `indexOf`, а у всех массивов – `forEach`.

У этих объектов (`Array.prototype`, `String.prototype`, ...) тоже есть свойство `__proto__`, которое ссылается на `Object.prototype`:

![Свойство `prototype` у встроенных типов](img/other.prototype.png)

У самого же `Object.prototype` свойство `__proto__` равно `null`.

Таким образом, у всех объектов встроенных ссылочных типов в конце цепочки прототипов находится `Object.prototype` (если, конечно, какие-либо прототипы не изменены вручную).
