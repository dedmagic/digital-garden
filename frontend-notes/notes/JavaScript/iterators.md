# Итераторы в JavaScript

## Стандартные итерируемые объекты

В стандартной библиотеке JavaScript есть некоторое количество т.н. _итерируемых_ объектов. Это объекты-коллекции, по элементам которых можно проходить с помощью цика `for/of` либо применять к ним деструктуризацию:

```js
const arr = [0, 1, 2, 3, 4];
for (let item of arr) {
    console.log(item); // Элементы массива в столбик (на отдельных строках экрана)
}
console.log(...arr); // 0 1 2 3 4

const str = 'Hello world';
for (let char of str) {
    console.log(char); // Символы строки в столбик (на отдельных строках экрана)
}
console.log(...str); // H e l l o   w o r l d

const set = new Set(arr);
console.log(...set); // 0 1 2 3 4
```

## Создание собственного итерируемого объекта

Рассмотрим на примере объекта "Диапазон", хранящего последовательность чисел:

```js
const range = {
    from: 1,
    to: 5
}
```

Чтобы сделать объект итерируемым, нужно в него добавить метод с именем `[Symbol.iterator]`, который будет возвращать специальный объект-итератор. Объект-итератор должен содержать метод `next()`, который при каждом вызове возвращает объект-результат вида `{ value: X, done: false|true }`, где в свойстве `value` содержится следующий элемент из коллекции, а в свойстве `done` – `false`, если конец коллекции ещё не достигнут, и `true` – если вся коллекция уже пройдена.

```js
const range = {
    from: 1,
    to: 5,

    [Symbol.iterator]: function () {
        return {
            current: this.from,
            last: this.to,

            next() {
                if (this.current <= this.last) {
                    return { value: this.current++, done: false }
                } else {
                    return { value: undefined, done: true }
                }
            }
        }
    }
}

for (let item of range) {
    console.log(item); // => 1 2 3 4 5 (на разных строках экрана)
}
```

При этом не обязательно объект-результат должен быть полным, достаточно возвращать только `value` на итерациях внутри коллекции и только `done: true` после окончания прохода:

```js
if (this.current <= this.last) {
    return { value: this.current++ }
} else {
    return { done: true }
}
```

## Сам себе итератор

При использовании итераторов в процессе участвует три объекта: итерируемый объект, объект-итератор и объект-результат итерации. Если есть желание сократить количество объектов, можно сам итерируемый объект сделать собственным итератором. Для этого надо в него из объекта-итератора перенести метод `next` и указатель на текущий элемент итерирования.

```js
const range = {
    from: 1,
    to: 5,

    next() {
        if (this.current <= this.to) {
            return { value: this.current++ }
        } else {
            return { done: true }
        }
    },

    [Symbol.iterator]() {
        this.current = this.from;
        return this;
    }
}
```

## Генераторы

На роль итераторов отлично подходят генераторы (вообще-то, они для этого и создавались). Генератор берёт на себя все инфраструктурные хлопоты: создание объектов итератора и результата операции, поддержка указателя на текущий элемент итерирования. В результате кода становится меньше, он становится чище и понятнее.

```js
const range = {
    from: 1,
    to: 5,

    *[Symbol.iterator]() {
        for (let i = this.from; i <= this.to; i++) {
            yield i;
        }
    }
}
```

## Дополнительные вопросы для изучения

- У объектов-итераторов кроме обязательного метода `next()` может быть ещё метод `return()`, который вызывается, если итерирование было прервано до достижения конца коллекции (внутри `for/of` сработал `break`).
